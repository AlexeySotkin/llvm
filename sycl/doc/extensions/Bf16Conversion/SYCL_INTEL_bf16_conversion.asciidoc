= SYCL_INTEL_bf16_conversion

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

// This is necessary for asciidoc, but not for asciidoctor
:cpp: C++

== Notice

IMPORTANT: This specification is a draft.

Copyright (c) 2021 Intel Corporation. All rights reserved.

NOTE: Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are
trademarks of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc.
used by permission by Khronos.

NOTE: This document is better viewed when rendered as html with asciidoctor.
GitHub does not render image icons.

== Dependencies

This extension is written against the SYCL 2020 specification, Revision 3.

== Status

Draft

This is a preview extension specification, intended to provide early access to
a feature for review and community feedback. When the feature matures, this
specification may be released as a formal extension.

Because the interfaces defined by this specification are not final and are
subject to change they are not intended to be used by shipping software
products.

== Version

Built On: {docdate} +
Revision: 1

== Introduction

This extension adds functionality to convert value of single-precision
floating-point type(`float`) to `bfloat16` type and vice versa. The extension
doesn't add support for `bfloat16` type as such, instead it uses 16-bit integer
type(`uint16_t`) as a storage for `bfloat16` values.

The purpose of conversion from float to bfloat16 is to reduce ammount of memory
required to store floating-point numbers. Computations are expected to be done with
32-bit floating-point values.


== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification section 6.3.3 "Feature test macros". Therefore, an implementation
supporting this extension must predefine the macro
`SYCL_EXT_INTEL_BF16_CONVERSION` to one of the values defined in the table
below. Applications can test for the existence of this macro to determine if
the implementation supports this feature, or applications can test the macro’s
 value to determine which of the extension’s APIs the implementation supports.

[%header,cols="1,5"]
|===
|Value |Description
|1     |Initial extension version. Base features are supported.
|===

== Extension to `enum class aspect`

[source]
----
namespace sycl {
enum class aspect {
  ...
  ext_intel_bf16_conversion
}
}
----

If a SYCL device has the `ext_intel_bf16_conversion` aspect, then it natively
supports conversion of values of `float` type to `bfloat16` and back.

If the device doesn't have the aspect, objects of `bfloat16` class ust not be
used in the device code.

== New `bfloat16` class

The following class provides the conversion functionality:

[source]
----
namespace sycl {
namespace ext {
namespace intel {
namespace experimental {

class bfloat16 {
  using storage_t = uint16_t;
  storage_t value;

public:
  // Direct initialization
  bfloat16(const storage_t& a)

  // Convert from float to bfloat16
  bfloat16(const float& a);

  // Convert from bfloat16 to float
  operator float() const;

  // Get bfloat16 as uint16.
  operator storage_t() const;
};

} // namespace experimental
} // namespace intel
} // namespace ext
} // namespace sycl
----

== Example

[source]
----
bfloat16 operator+(const bfloat16 &lhs, const bfloat16 &rhs) {
  return static_cast<float>(lhs) + static_cast<float>(rhs);
}

float foo(float a, float b) {
  // Convert from float to bfloat16.
  bfloat16 A {a};
  bfloat16 B {b};

  // Convert A and B from bfloat16 to float, do addition on floating-pointer
  // numbers, then convert the result to bfloat16 and store in C.
  bfloat16 C = A + B;

  // Return the result converted from bfloat16 to float.
  return C;
}

int main (int argc, char *argv[])
{
    float data[3] = {7.0, 8.1, 0.0};
    cl::sycl::queue deviceQueue;
    cl::sycl::buffer<float, 1> buf {data, cl::sycl::range<1> {3}};

    deviceQueue.submit ([&] (cl::sycl::handler& cgh)
    {
        auto numbers = buf.get_access<cl::sycl::access::mode::read_write> (cgh);
        cgh.single_task<class simple_kernel> ([=] ()
        {
            numbers[2] = foo(numbers[0], numbers[1]);

        });
    });
  return 0;
}
----

== Issues

None.

== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|1|2021-08-02|Alexey Sotkin |*Initial public working draft*
|========================================

//************************************************************************
//Other formatting suggestions:
//
//* Use *bold* text for host APIs, or [source] syntax highlighting.
//* Use +mono+ text for device APIs, or [source] syntax highlighting.
//* Use +mono+ text for extension names, types, or enum values.
//* Use _italics_ for parameters.
//************************************************************************

